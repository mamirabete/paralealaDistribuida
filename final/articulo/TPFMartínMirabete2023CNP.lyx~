#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass llncs
\begin_preamble

%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\end_preamble
\options runningheads
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package auto
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mainmatter
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% start of an individual contribution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% first the title is needed
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Title
TRABAJO PRACTICO FINAL
\begin_inset Newline newline
\end_inset

“PARADIGMAS DE COMPUTACIÓN PARALELA, 
\begin_inset Newline newline
\end_inset

CONCURRENTE Y DISTRIBUIDA”
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% a short form should be given in case it is too long for the running head
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Running LaTeX Title
TPF - Paradigmas de Computación Paralela, Concurrente y Distribuida
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the name(s) of the author(s) follow(s) next
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% NB: Chinese authors should write their first names(s) in front of
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% their surnames.
 This ensures that the names appear correctly in
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the running heads and the author index.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Author
Martín Mirabete
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Tenga en cuenta que la editorial asume que todos los autores han utilizado
 la convención de nomenclatura occidental, con nombres de pila que preceden
 a los apellidos.
 Esto determina la estructura de los nombres en los encabezados y el índice
 de autor.
\end_layout

\end_inset


\end_layout

\begin_layout Author Running
TPF - Paradigmas de Computación Paralela, Concurrente y Distribuida
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% (feature abused for this document to repeat the title also on left hand
 pages)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% the affiliations are given next; don't give your e-mail address
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% unless you accept that it will be published
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Institute
Laboratorio de Tecnologías Emergentes (LabTEm),
\begin_inset Newline newline
\end_inset

Instituto de Tecnología Aplicada (ITA),
\begin_inset Newline newline
\end_inset

Unidad Académica Caleta Olivia (UACO),
\begin_inset Newline newline
\end_inset

Universidad Nacional de la Patagonia Austral (UNPA),
\begin_inset Newline newline
\end_inset

Ruta N° 3 Acceso Norte, Caleta Olivia, Santa Cruz, Argentina
\begin_inset Newline newline
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
mailsa
\end_layout

\end_inset

mmirabete@uaco.unpa.edu.ar
\begin_inset Newline newline
\end_inset

 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.uaco.unpa.edu.ar/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% NB: a more complex sample for affiliations and the mapping to the
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% corresponding authors can be found in the file "llncs.dem"
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% (search for the string "
\backslash
mainmatter" where a contribution starts).
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% "llncs.dem" accompanies the document class "llncs.cls".
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout TOC Title
Lecture Notes in Computer Science
\end_layout

\begin_layout TOC Author
Authors' Instructions
\end_layout

\begin_layout Abstract
The abstract should summarize the contents of the paper and should contain
 at least 70 and at most 150 words.
 It should be written using the 
\emph on
abstract
\emph default
 environment.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
keywords{
\end_layout

\end_inset

We would like to encourage you to list your keywords within the abstract
 section
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
El siguiente informe ha sido elaborado para dar cumplimiento a lo requerido
 en el Trabajo Práctico Final de “Paradigmas de Computación Paralela, Concurrent
e y Distribuida”.
 En este trabajo, se solicita la implementación de la multiplicación vectorial
 y escalar de dos vectores de 100 elementos, utilizando un lenguaje de programac
ión y una librería de programación en paralelo previamente seleccionados.
\end_layout

\begin_layout Standard
Para llevar a cabo esta tarea, se ha elegido el lenguaje de programación
 ANSI C y la librería de programación en paralelo MPI.
 Se implementará la multiplicación vectorial y escalar de dos vectores de
 100 elementos.
 Donde el primer vector contendrá como elementos los primeros 100 términos
 de la serie de números naturales impares y el segundo vector tendrá los
 primeros 100 términos de la serie de números naturales pares (incluyendo
 el 0).
\end_layout

\begin_layout Standard
El objetivo de la implementación es obtener el resultado de la multiplicación
 de los vectores y medir el tiempo empleado en el cálculo.
 Además, se llevará a cabo una versión paralela y secuencial del programa
 para poder comparar los resultados obtenidos.
\end_layout

\begin_layout Standard
Posteriormente, se realizará la misma tarea para dos vectores de tamaños
 crecientes: 1000, 5.000, 10.000, 50.000, 100.000, 200.000, 300.000, 400.000, 500.000,
 1.000.000 y 10.000.000 de elementos, siempre y cuando sea soportado por el
 hardware utilizado.
\end_layout

\begin_layout Standard
Una vez que se hayan obtenido los resultados, se graficarán los tiempos
 paralelos y secuenciales para cada tamaño de vector.
 A continuación, se realizará una explicación de los valores obtenidos,
 estableciendo su relación con el concepto de Speedup y Eficiencia.
 El Speedup representa la mejora de rendimiento obtenida al utilizar la
 programación paralela en comparación con la secuencial, mientras que la
 Eficiencia se refiere a la proporción de tiempo empleado en relación al
 número de procesadores utilizados.
\end_layout

\begin_layout Section
Desarrollo
\end_layout

\begin_layout Subsection
Elección del lenguaje de programación
\end_layout

\begin_layout Standard
La elección del lenguaje ANSI C para completar el ejercicio de paradigmas
 de procesamiento paralelo y distribuido se basa en varias razones fundamentales.
\end_layout

\begin_layout Standard
En primer lugar, se selecciona el lenguaje ANSI C debido a su eficiencia
 y capacidad para ofrecer un control preciso sobre los recursos del sistema.
 ANSI C es un lenguaje de bajo nivel que permite optimizar el código y acceder
 directamente a la memoria, lo cual resulta crucial en entornos de procesamiento
 paralelo y distribuido.
\end_layout

\begin_layout Standard
ANSI C permite una gestión eficiente de los recursos y ofrece un alto grado
 de control sobre el rendimiento de las aplicaciones.
\end_layout

\begin_layout Standard
Además, el lenguaje ANSI C cuenta con un amplio soporte en el ámbito de
 la programación paralela y distribuida.
 Existen numerosas bibliotecas y herramientas diseñadas específicamente
 para trabajar con ANSI C en entornos de procesamiento paralelo, como la
 librería MPI.
 Esta librería, es una interfaz estándar ampliamente utilizada para la comunicac
ión entre procesos en sistemas paralelos y distribuidos, y ANSI C es uno
 de los lenguajes compatibles con esta librería.
\end_layout

\begin_layout Standard
Por último, ANSI C ha demostrado ser capaz de manejar eficientemente cálculos
 intensivos y algoritmos paralelos.
 
\end_layout

\begin_layout Subsection
Elección de la librería para programación en paralelo
\end_layout

\begin_layout Standard
Se ha optado por la librería MPI.
 Esta selección ha sido hecha por varias razones, que se pasan a explicar.
 En primer lugar, MPI (Message Passing Interface) es una interfaz estándar
 ampliamente utilizada en programación paralela y distribuida, lo que garantiza
 su compatibilidad con una amplia gama de sistemas y plataformas.
\end_layout

\begin_layout Standard
Además, MPI ofrece una gran flexibilidad y eficiencia en la comunicación
 entre los diferentes procesos paralelos.
 Proporciona un conjunto de funciones que permiten el intercambio de mensajes
 y datos entre los nodos de un sistema distribuido, lo cual es fundamental
 en la implementación de algoritmos paralelos y la sincronización de tareas.
\end_layout

\begin_layout Standard
Otra ventaja significativa de MPI es su capacidad para escalar el rendimiento
 a medida que se agregan más nodos de procesamiento.
 Esto significa que a medida que se aumenta la cantidad de recursos disponibles,
 como procesadores y memoria, la librería MPI puede aprovecharlos de manera
 efectiva y distribuir la carga de trabajo de manera equitativa.
\end_layout

\begin_layout Standard
Además, MPI ofrece mecanismos avanzados para el manejo de errores y recuperación
, lo que es crucial en entornos de cómputo paralelo donde pueden ocurrir
 fallas o interrupciones en el sistema.
\end_layout

\begin_layout Standard
Finalmente, la elección de la librería MPI para el procesamiento paralelo
 se basa en su amplia adopción, compatibilidad, flexibilidad en la comunicación,
 capacidad de escalamiento y manejo de errores.
 Estas características hacen de MPI una opción sólida y confiable para implement
ar aplicaciones paralelas y cumplir con los requisitos del trabajo práctico.
\end_layout

\begin_layout Subsection
Implemente la multiplicación escalar, en programación secuencial.
\end_layout

\begin_layout Standard
El código del programa 
\shape italic
ProductoEscalarS.c
\shape default
 implementa el cálculo del producto escalar entre dos vectores en programación
 secuencial.
 A continuación, describiré paso a paso la implementación:
\end_layout

\begin_layout Enumerate
Se incluyen las bibliotecas necesarias para el funcionamiento del programa,
 como stdio.h, stdlib.h, time.h y sys/time.h.
\end_layout

\begin_layout Enumerate
Se define la constante CANTIDAD_DEF con un valor predeterminado de 100,
 que representa la cantidad de elementos en los vectores.
\end_layout

\begin_layout Enumerate
Se declara la función principal main con los parámetros argc y argv[].
\end_layout

\begin_layout Enumerate
Se declaran las variables necesarias, como cantidadElementos para almacenar
 la cantidad de elementos en los vectores, par e impar para contar la cantidad
 de números pares e impares, respectivamente, count para controlar los bucles,
 outCsv para indicar si se generará en formato CSV la salida, encabezado
 para determinar si se imprimirá un encabezado en la salida y productoEscalar
 para almacenar el resultado del producto escalar.
\end_layout

\begin_layout Enumerate
Se declaran estructuras de tiempo, inicio y fin, utilizando struct timeval
 para medir el tiempo de ejecución en microsegundos, y las variables iniSeg
 y finSeg utilizando clock_t para medir el tiempo de ejecución en segundos.
\end_layout

\begin_layout Enumerate
Se realiza una verificación de los parámetros proporcionados a través de
 argc para determinar si se especificó la cantidad de elementos, la opción
 de formato CSV y la opción de encabezado.
\end_layout

\begin_layout Enumerate
Se asigna el valor proporcionado o predeterminado a cantidadElementos dependiend
o de los parámetros ingresados.
\end_layout

\begin_layout Enumerate
Se actualizan las variables outCsv y encabezado según los parámetros ingresados.
\end_layout

\begin_layout Enumerate
Se guarda el tiempo de inicio de la ejecución utilizando clock() y gettimeofday(
).
\end_layout

\begin_layout Enumerate
Se crean los vectores vectorA y vectorB utilizando punteros a enteros.
\end_layout

\begin_layout Enumerate
Se asigna memoria dinámicamente a los vectores utilizando malloc según la
 cantidad de elementos especificada en cantidadElementos.
\end_layout

\begin_layout Enumerate
Se verifica si la asignación de memoria fue exitosa.
 Si alguno de los vectores es NULL, se imprime un mensaje de error y se
 sale del programa.
\end_layout

\begin_layout Enumerate
Se cargan los vectores vectorA y vectorB con números pares e impares, respectiva
mente, utilizando un bucle for.
 Los números pares se agregan a vectorA y los impares a vectorB.
\end_layout

\begin_layout Enumerate
Se calcula el producto escalar entre los dos vectores utilizando un bucle
 for.
 Se multiplica cada elemento correspondiente en vectorA y vectorB y se suma
 al resultado en productoEscalar.
\end_layout

\begin_layout Enumerate
Se guarda el tiempo de finalización de la ejecución utilizando clock() y
 gettimeofday().
\end_layout

\begin_layout Enumerate
Se calcula el tiempo de ejecución en microsegundos y segundos utilizando
 las diferencias de tiempo almacenadas.
\end_layout

\begin_layout Enumerate
Si la opción de formato CSV no está habilitada, se imprime el resultado
 del producto escalar y el tiempo de ejecución en microsegundos y segundos.
\end_layout

\begin_layout Enumerate
Si la opción de formato CSV está habilitada, se imprime un encabezado si
 corresponde y se imprime la cantidad de elementos, el producto escalar
 y los tiempos de ejecución en microsegundos y segundos separados por comas.
\end_layout

\begin_layout Enumerate
Se libera la memoria asignada a los vectores utilizando free.
\end_layout

\begin_layout Enumerate
Se retorna 0 para indicar que el programa se ejecutó correctamente.
\end_layout

\begin_layout Standard
Este código, como se comentó con anterioridad, calcula el producto escalar
 de dos vectores, de acuerdo a las convenciones establecidas en el seminario,
 en programación secuencial.
 El primer vector tiene como elementos los primeros 100 términos de la serie
 de números naturales impares.
 El segundo vector contiene los primeros 100 términos de la serie de números
 naturales pares (incluyendo el 0).
 Muestra el resultado, así como el tiempo de ejecución en microsegundos
 y segundos.
 También puede generar la salida en formato CSV con los resultados si se
 especifica la opción correspondiente.
\end_layout

\begin_layout Subsection
Implemente la multiplicación vectorial, en programación secuencial.
\end_layout

\begin_layout Standard
Este código de programación, contenido en el archivo ProductoVectorialS.c,
 implementa el cálculo del producto vectorial en programación secuencial.
 A continuación, describiré paso a paso la implementación:
\end_layout

\begin_layout Enumerate
Se incluyen las bibliotecas necesarias para el funcionamiento del programa,
 como stdio.h, stdlib.h, time.h y sys/time.h.
\end_layout

\begin_layout Enumerate
Se define la constante CANTIDAD_DEF con un valor predeterminado de 100,
 que representa la cantidad de elementos por defecto en los vectores.
\end_layout

\begin_layout Enumerate
Se declara la función principal main con los parámetros argc y argv[].
\end_layout

\begin_layout Enumerate
Se declara la variable cantidadElementos e se inicializa con el valor de
 CANTIDAD_DEF por defecto.
\end_layout

\begin_layout Enumerate
Se declara la variable outCsv e encabezado y se inicializan en 0, que se
 utilizarán para controlar la generación la salida en formato CSV y la inclusión
 de un encabezado en la salida.
\end_layout

\begin_layout Enumerate
Se declaran las variables count1 y count2 para utilizar en bucles y las
 variables de puntero vectorA, vectorB y productoVectorial.
\end_layout

\begin_layout Enumerate
Se declaran estructuras de tiempo, inicio y fin, utilizando struct timeval
 para medir el tiempo de ejecución en microsegundos, y las variables iniSeg
 y finSeg utilizando clock_t para medir el tiempo de ejecución en segundos.
\end_layout

\begin_layout Enumerate
Se verifica si se han proporcionado los parámetros requeridos en la línea
 de comandos.
 Si no se proporcionaron, se muestra un mensaje de error y se imprime la
 cantidad de elementos por defecto y el formato de uso del programa.
\end_layout

\begin_layout Enumerate
Si se proporcionaron los parámetros requeridos, se actualiza la variable
 cantidadElementos según el valor proporcionado.
\end_layout

\begin_layout Enumerate
Se verifica si se proporcionaron los parámetros opcionales para el formato
 CSV y el encabezado.
 Si se proporcionaron, se actualizan las variables outCsv y encabezado en
 consecuencia.
\end_layout

\begin_layout Enumerate
Se guarda el tiempo de inicio de la ejecución utilizando clock() y gettimeofday(
).
\end_layout

\begin_layout Enumerate
Se asigna memoria dinámicamente a los vectores vectorA, vectorB y productoVector
ial según la cantidad de elementos.
\end_layout

\begin_layout Enumerate
Se verifica si la asignación de memoria fue exitosa.
 Si alguno de los vectores es NULL, se imprime un mensaje de error, se finaliza
 el programa.
\end_layout

\begin_layout Enumerate
Se llenan los vectores vectorA y vectorB con los números naturales impares
 y pares, respectivamente, utilizando bucles for.
\end_layout

\begin_layout Enumerate
Se realiza el cálculo del producto vectorial utilizando un bucle anidado.
 Para cada elemento del vector resultante, se suma el producto de los elementos
 correspondientes de vectorA y vectorB.
\end_layout

\begin_layout Enumerate
Se guarda el tiempo de finalización de la ejecución utilizando clock() y
 gettimeofday().
\end_layout

\begin_layout Enumerate
Se calcula el tiempo de ejecución en microsegundos (tiempo) y en segundos
 (tiempoSeg).
\end_layout

\begin_layout Enumerate
Si no se especificó la opción de formato CSV, se imprime por pantalla el
 resultado del producto vectorial y el tiempo de ejecución en microsegundos
 y segundos.
\end_layout

\begin_layout Enumerate
Si se especificó la opción de formato CSV, se imprime un encabezado en el
 archivo CSV si se proporcionó la opción de encabezado.
 Luego se imprime la cantidad de elementos, el tiempo de ejecución en microsegun
dos y el tiempo de ejecución en segundos en el archivo CSV.
\end_layout

\begin_layout Enumerate
Se libera la memoria asignada a los vectores vectorA, vectorB y productoVectoria
l utilizando free().
\end_layout

\begin_layout Enumerate
Se retorna 0 para indicar que el programa se ejecutó correctamente.
\end_layout

\begin_layout Standard
El producto vectorial de dos vectores es calculado por este código, en programac
ión secuencial, según lo discutido previamente.
 Las convenciones establecidas en el seminario sobre producto vectorial
 y escalar son seguidas.
 El primer vector está compuesto por los primeros 100 términos de la serie
 de números naturales impares.
 El segundo vector está compuesto por los primeros 100 términos de la serie
 de números naturales pares, incluyendo el 0.
 El resultado, junto con el tiempo de ejecución en microsegundos y segundos,
 es mostrado.
 Si se especifica la opción correspondiente, también puede generar la salida
 en formato CSV con los resultados.
\end_layout

\begin_layout Subsection
Implemente la multiplicación escalar, en programación paralela.
\end_layout

\begin_layout Standard
Es implementado en este archivo de programa (ProductoEscalarP.c) el cálculo
 del producto escalar en programación paralela utilizando MPI (Message Passing
 Interface).
 El código de programa explicado en el apartado 2.3 sirvió como base, donde
 la multiplicación escalar fue implementada en programación secuencial.
 Por lo tanto, para no ser redundantes, las líneas de código donde se implementa
 la programación paralela son el enfoque principal.
 A continuación, se describe la implementación:
\end_layout

\begin_layout Enumerate
Se incluyen las bibliotecas necesarias para el funcionamiento del programa
 y mpi.h (para MPI).
\end_layout

\begin_layout Enumerate
Luego de declarar e inicializar las estructuras, variables, constantes y
 establecer los valores predeterminados, se inicializa MPI utilizando MPI_Init().
\end_layout

\begin_layout Enumerate
Se obtiene el rango del proceso actual (miRango) y el número total de procesos
 (numProcs) utilizando MPI_Comm_rank() y MPI_Comm_size().
\end_layout

\begin_layout Enumerate
Se verifica si se han proporcionado los parámetros requeridos en la línea
 de comandos.
 Si se proporcionaron los parámetros requeridos, se actualiza la variable,
 según los valores proporcionados.
 En caso contrario, se muestra un mensaje de error y se imprime la cantidad
 de elementos por defecto, la cantidad de procesadores y el formato de uso
 del programa.
\end_layout

\begin_layout Enumerate
Se divide el trabajo entre los procesos utilizando elementosPorProceso y
 elementosRestantes.
\end_layout

\begin_layout Enumerate
Se asigna memoria dinámicamente a los vectores vectorA y vectorB utilizando
 malloc().
\end_layout

\begin_layout Enumerate
Se verifica si la asignación de memoria fue exitosa.
 Si alguno de los vectores es NULL, se imprime un mensaje de error, se finaliza
 el programa y se llama a MPI_Finalize() para finalizar MPI.
\end_layout

\begin_layout Enumerate
Se llenan los vectores vectorA y vectorB con los números pares e impares
 respectivamente, utilizando bucles for.
\end_layout

\begin_layout Enumerate
Si hay elementos restantes, se procesan en el proceso 0.
\end_layout

\begin_layout Enumerate
Se calcula el producto escalar parcial entre los elementos de los vectores
 vectorA y vectorB.
\end_layout

\begin_layout Enumerate
Se utiliza MPI_Reduce() para sumar los productos escalares parciales de
 todos los procesos y obtener el producto escalar final en el proceso 0.
\end_layout

\begin_layout Enumerate
Se guarda el tiempo de finalización de la ejecución.
 Y se calcula el tiempo de ejecución en microsegundos y en segundos.
\end_layout

\begin_layout Enumerate
Se muestra el resultado final en el proceso 0.
 Tomando en cuenta los parámetros recibidos en la línea de comandos.
\end_layout

\begin_layout Enumerate
Se libera la memoria asignada a los vectores vectorA y vectorB utilizando
 free().
\end_layout

\begin_layout Enumerate
Se llama a MPI_Finalize() para finalizar MPI.
\end_layout

\begin_layout Enumerate
Se retorna 0 para indicar que el programa se ejecutó correctamente.
\end_layout

\begin_layout Standard
En este código de programa, a diferencia del explicado en el apartado 2.3,
 se utiliza la librería MPI para implementar la programación paralela.
 Para ello, se hace uso de varias funciones de MPI.
 En primer lugar, la función MPI_Init es empleada para inicializar MPI y
 establecer el entorno de comunicación.
 A continuación, la función MPI_Comm_rank es utilizada para obtener el rango
 del proceso, es decir, su identificador único.
 Asimismo, se emplea la función MPI_Comm_size para obtener el número total
 de procesos involucrados en la comunicación.
\end_layout

\begin_layout Standard
Además, se hace uso de la función MPI_Reduce, la cual permite sumar los
 productos escalares parciales de todos los procesos.
 Esta función es utilizada para realizar una operación de reducción en la
 cual se combina el resultado de cada proceso en uno solo.
\end_layout

\begin_layout Standard
Por otro lado, la función MPI_Finalize es llamada para finalizar MPI y liberar
 los recursos asociados con la comunicación una vez que se ha completado
 la ejecución del programa.
\end_layout

\begin_layout Standard
En cuanto a la distribución del trabajo entre los procesos, se divide utilizando
 la variable "elementosPorProceso".
 Cada proceso se encarga de una porción del trabajo, mientras que los elementos
 restantes son manejados en el proceso 0.
\end_layout

\begin_layout Subsection
Implemente la multiplicación vectorial, en programación paralela.
\end_layout

\begin_layout Standard
El código expuesto en el programa ProductoVectorialP.c implementa el cálculo
 del producto vectorial en programación paralela utilizando MPI (Message
 Passing Interface).
 Como se mencionó en el apartado anterior nos hemos basado en el código
 de programación desarrollado en el apartado 2.4, donde el producto vectorial
 fue implementado en programación secuencial.
 Por lo tanto, nos enfocaremos en describir las líneas de código donde se
 implementa la programación paralela, a continuación:
\end_layout

\begin_layout Enumerate
Se incluyen las bibliotecas necesarias para el funcionamiento del programa
 y mpi.h (para MPI).
\end_layout

\begin_layout Enumerate
Luego de declarar e inicializar las estructuras, variables, constantes y
 establecer los valores predeterminados, se inicializa MPI utilizando MPI_Init().
\end_layout

\begin_layout Enumerate
Se obtiene el rango del proceso actual (miRango) y el número total de procesos
 (numProcs) utilizando MPI_Comm_rank() y MPI_Comm_size().
\end_layout

\begin_layout Enumerate
Se verifica si se han proporcionado los parámetros requeridos en la línea
 de comandos.
 Si se proporcionaron los parámetros requeridos, se actualiza la variable,
 según los valores proporcionados.
 En caso contrario, se muestra un mensaje de error y se imprime la cantidad
 de elementos por defecto, la cantidad de procesadores y el formato de uso
 del programa.
\end_layout

\begin_layout Enumerate
Se difunden los datos de cantidadElementos, outCsv y encabezado a todos
 los procesos utilizando MPI_Bcast().
\end_layout

\begin_layout Enumerate
Se asigna memoria dinámicamente a los vectores vectorA, vectorB y productoVector
ial utilizando malloc().
\end_layout

\begin_layout Enumerate
Se verifica si la asignación de memoria fue exitosa.
 Si alguno de los vectores es NULL, se imprime un mensaje de error, se finaliza
 el programa y se llama a MPI_Finalize() para finalizar MPI.
\end_layout

\begin_layout Enumerate
En cada proceso, se llena el vector vectorA con los primeros n números naturales
 impares y el vector vectorB con los primeros n números naturales pares,
 utilizando bucles for con un salto de numProcs.
\end_layout

\begin_layout Enumerate
Cada proceso calcula su parte del producto vectorial utilizando un bucle
 for anidado.
 Se inicializa el elemento correspondiente del vector productoVectorial
 a 0 y se realizan las multiplicaciones correspondientes.
\end_layout

\begin_layout Enumerate
En el proceso 0, se asigna memoria dinámicamente al vector resultados para
 almacenar los resultados finales.
\end_layout

\begin_layout Enumerate
Se utiliza MPI_Gather() para recopilar los resultados parciales de cada
 proceso en el proceso 0.
\end_layout

\begin_layout Enumerate
Se guarda el tiempo de finalización de la ejecución.
 Y se calcula el tiempo de ejecución en microsegundos y en segundos.
\end_layout

\begin_layout Enumerate
Se muestra el resultado final en el proceso 0.
 Tomando en cuenta los parámetros recibidos en la línea de comandos.
\end_layout

\begin_layout Enumerate
Se libera la memoria asignada a los vectores vectorA, vectorB y productoVectoria
l utilizando free().
\end_layout

\begin_layout Enumerate
Se llama a MPI_Finalize() para finalizar MPI.
\end_layout

\begin_layout Enumerate
Se retorna 0 para indicar que el programa se ejecutó correctamente.
\end_layout

\begin_layout Standard
Para implementar la librería MPI en el código de ProsuctoVectorialS.c (apartado
 2.4), es necesario establecer la comunicación entre los procesos.
 Para esto, se debe dividir el trabajo y asignar una parte de los vectores
 a cada proceso.
 Cada proceso debe calcular la suma de los productos de los elementos correspond
ientes de los dos vectores asignados y enviar el resultado al proceso principal.
 El proceso principal luego suma los resultados para obtener el producto
 escalar total.
\end_layout

\begin_layout Standard
En el código estudiado, la comunicación entre los procesos es establecida
 utilizando la librería MPI (Message Passing Interface).
 Un conjunto de funciones y rutinas es proporcionado por esta librería,
 permitiendo que los datos sean intercambiados y las acciones sean coordinadas
 por los procesos en un entorno de programación paralela.
 Los siguientes pasos fueron seguidos para implementar la comunicación entre
 los procesos:
\end_layout

\begin_layout Enumerate
La 
\shape italic
inicialización
\shape default
 se realiza llamando a la función MPI_Init por parte de cada proceso, con
 el objetivo de inicializar MPI y establecer el entorno de comunicación.
 Es importante destacar que esta función debe ser llamada antes de cualquier
 otra función MPI.
\end_layout

\begin_layout Enumerate
La 
\shape italic
identificación del rango
\shape default
 y tamaño se realiza mediante la llamada a la función MPI_Comm_rank por
 parte de cada proceso, con el fin de obtener su identificador único, conocido
 como "rango".
 El rango es un número entero que abarca desde 0 hasta el número total de
 procesos -1.
 Asimismo, la función MPI_Comm_size es utilizada para determinar el número
 total de procesos involucrados en la comunicación.
\end_layout

\begin_layout Enumerate
En la 
\shape italic
definición del proceso emisor y receptor 
\shape default
del mensaje, se selecciona el contenido del mensaje y se almacena en una
 variable en el proceso emisor, el cual posee los datos que se desean enviar.
\end_layout

\begin_layout Enumerate
El 
\shape italic
envío del mensaje
\shape default
 se realiza utilizando la función MPI_Bcast, la cual transmite el contenido
 del mensaje desde el proceso emisor a todos los demás procesos.
 Esta función es llamada en todos los procesos, tanto en el emisor como
 en los receptores.
 Los parámetros de la función incluyen el puntero al contenido del mensaje,
 el tamaño del mensaje, el tipo de dato del mensaje y el rango del proceso
 emisor.
 Con el uso de la función MPI_Bcast, se simplifica la tarea de enviar un
 mensaje a todos los procesos en una comunicación colectiva, evitando la
 necesidad de utilizar múltiples llamadas a MPI_Send y MPI_Recv.
\end_layout

\begin_layout Enumerate

\shape italic
Recepción del mensaje
\shape default
: El mensaje transmitido por el proceso emisor se recibirá automáticamente
 en los procesos receptores y se almacenará en una variable local.
\end_layout

\begin_layout Enumerate
La función MPI_Gather es utilizada para 
\shape italic
recopilar los datos
\shape default
 de todos los procesos y reunirlos en un solo proceso.
 En todos los procesos, se realiza la llamada a esta función, especificando
 el puntero a los datos locales, el tamaño de cada dato local, el tipo de
 dato y el rango del proceso receptor.
\end_layout

\begin_layout Enumerate

\shape italic
Finalización
\shape default
: Una vez completada la comunicación y recopilación de datos, se realiza
 la llamada a la función MPI_Finalize para finalizar MPI y liberar los recursos
 asociados con la comunicación.
\end_layout

\begin_layout Standard
Estos pasos permitieron establecer la comunicación entre los procesos utilizando
 la librería MPI, lo que facilita la implementación de la programación paralela
 y el intercambio de datos en un entorno distribuido.
\end_layout

\begin_layout Subsection
Descripción del entorno de prueba.
\end_layout

\begin_layout Standard
El entorno de pruebas para la ejecución de estos ejercicios de programación
 paralelo y secuencial, donde se implementa la multiplicación vectorial
 y escalar de dos vectores con una cantidad de elementos diversos, está
 compuesto por una Notebook Dell Inc.
 Latitude 3500.
\end_layout

\begin_layout Standard
La misma está equipada con un procesador Intel® Core™ i7-8565U CPU @ 1.80GHz
 × 8, el cual proporciona la capacidad de procesamiento necesaria para ejecutar
 los ejercicios de manera eficiente.
 La memoria RAM de 8 GB permite almacenar y manipular los datos utilizados
 en los cálculos de la multiplicación vectorial y escalar.
\end_layout

\begin_layout Standard
Además, la Notebook Dell Inc.
 Latitude 3500 cuenta con un disco SSD de 240 GB, lo que permite un acceso
 rápido a los archivos y datos necesarios durante la ejecución de los ejercicios.
\end_layout

\begin_layout Standard
En cuanto a la interfaz de video, se utiliza Mesa Intel® UHD Graphics 620
 (WHL GT2), lo que proporciona una representación visual adecuada para cualquier
 componente gráfico requerido por los ejercicios de programación.
\end_layout

\begin_layout Standard
El sistema operativo utilizado en este entorno de pruebas se basa en GNU/Linux
 kernel 5.19.0-41-generic, concretamente en una distribución Ubuntu 22.04.2
 LTS para 64 bits.
 Esta elección de sistema operativo proporciona una plataforma estable y
 confiable para la ejecución de los ejercicios.
\end_layout

\begin_layout Standard
Para la compilación de los ejercicios, se utiliza el compilador gcc en su
 versión 11.3.0.
 Este compilador permite generar el código ejecutable a partir del código
 fuente de los ejercicios de programación paralelo y secuencial.
\end_layout

\begin_layout Standard
Además, se utiliza la librería MPI en su versión 4.1.2, la cual proporciona
 las funcionalidades necesarias para la programación paralela y la comunicación
 entre los diferentes procesos involucrados en la ejecución de los ejercicios.
\end_layout

\begin_layout Standard
Es importante destacar que se iniciará el sistema operativo (SO) en runtime
 nivel 1 para la ejecución de las pruebas.
 Este nivel de ejecución, también conocido como "modo monousuario" o "modo
 de mantenimiento", es un nivel de ejecución en el cual el sistema operativo
 es iniciado con un conjunto mínimo de servicios y procesos.
 Al iniciar el SO GNU/Linux en runtime 1, se logra que el SO funcione en
 un modo de ejecución básico y restringido, el cual proporciona acceso limitado.
 El runtime nivel 1 es utilizado cuando se requiere un control total sobre
 el sistema operativo.
\end_layout

\begin_layout Subsection
Desarrollo de ejercicios para cada versión y comparación de resultados
\end_layout

\begin_layout Standard
A continuación, se muestra el resultado de la multiplicación vectorial y
 escalar de dos vectores de 100 elementos y el tiempo empleado en la computación
 del cálculo.
 La implementación se realizó tanto en programación secuencial como paralela.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\lang spanish

\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad Elementos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad Procesos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ejecución en µs.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Secuencial
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Paralela
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
247
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Paralela
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
97
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Paralela
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
123
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Resultados del producto escalar de dos vectores de 100 elementos.
 Estrategia secuencial y paralela.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fig.
 1.
 Representación gráfica del tiempo empleado en la computación del cálculo
 del producto escalar de dos vectores de 100 elementos empleando estrategias
 secuencial y paralela.
\end_layout

\begin_layout Subsection
Desarrollo de ejercicios para cada versión con escalamiento de elementos
 y comparación de resultados.
\end_layout

\begin_layout Standard
A continuación, se presenta el resultado de la multiplicación vectorial
 y escalar de dos vectores con diferentes cantidades de elementos (1000,
 5.000, 10.000, 50.000, 100.000, 200.000, 300.000, 400.000, 500.000, 1.000.000) y
 el tiempo empleado en la computación del cálculo.
 Tanto la programación secuencial como la programación paralela fueron implement
adas.
 Se destaca que, debido a la prolongada duración del cálculo con vectores
 de más de 1.000.000 de elementos, se estableció este límite como una consideració
n práctica.
\end_layout

\begin_layout Subsection
Footnotes
\end_layout

\begin_layout Standard
The superscript numeral used to refer to a footnote appears in the text
 either directly after the word to be discussed or – in relation to a phrase
 or a sentence – following the punctuation sign (comma, semicolon, or period).
 Footnotes should appear at the bottom of the normal text area, with a line
 of about 2
\begin_inset space ~
\end_inset

cm set immediately above them.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The footnote numeral is set flush left and the text follows with the usual
 word spacing.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Program Code
\end_layout

\begin_layout Standard
Program listings or program commands in the text are normally set in typewriter
 font, e.g., CMTT10 or Courier.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\noindent

\shape italic
Example of a Computer Program
\shape default
 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

program Inflation (Output)
\end_layout

\begin_layout Verbatim

  {Assuming annual inflation rates of 7%, 8%, and 10%,...
\end_layout

\begin_layout Verbatim

   years};
\end_layout

\begin_layout Verbatim

   const
\end_layout

\begin_layout Verbatim

     MaxYears = 10;
\end_layout

\begin_layout Verbatim

   var
\end_layout

\begin_layout Verbatim

     Year: 0..MaxYears;
\end_layout

\begin_layout Verbatim

     Factor1, Factor2, Factor3: Real;
\end_layout

\begin_layout Verbatim

   begin
\end_layout

\begin_layout Verbatim

     Year := 0;
\end_layout

\begin_layout Verbatim

     Factor1 := 1.0; Factor2 := 1.0; Factor3 := 1.0;
\end_layout

\begin_layout Verbatim

     WriteLn('Year  7% 8% 10%'); WriteLn;
\end_layout

\begin_layout Verbatim

     repeat
\end_layout

\begin_layout Verbatim

       Year := Year + 1;
\end_layout

\begin_layout Verbatim

       Factor1 := Factor1 * 1.07;
\end_layout

\begin_layout Verbatim

       Factor2 := Factor2 * 1.08;
\end_layout

\begin_layout Verbatim

       Factor3 := Factor3 * 1.10;
\end_layout

\begin_layout Verbatim

       WriteLn(Year:5,Factor1:7:3,Factor2:7:3,Factor3:7:3)
\end_layout

\begin_layout Verbatim

     until Year = MaxYears
\end_layout

\begin_layout Verbatim

end.
\end_layout

\begin_layout Standard
\noindent

\size small
(Example from Jensen K., Wirth N.
 (1991) Pascal user manual and report.
 Springer, New York)
\end_layout

\begin_layout Subsection
Citations
\end_layout

\begin_layout Standard
For citations in the text please use square brackets and consecutive numbers:
 
\begin_inset CommandInset citation
LatexCommand cite
key "jour"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "lncschap"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "proceeding1"
literal "false"

\end_inset

 – provided automatically by \SpecialChar LaTeX
's 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|
\backslash
cite|
\end_layout

\end_inset

 …
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|
\backslash
bibitem|
\end_layout

\end_inset

 mechanism.
\end_layout

\begin_layout Subsection
Page Numbering and Running Heads
\end_layout

\begin_layout Standard
There is no need to include page numbers.
 If your paper title is too long to serve as a running head, it will be
 shortened.
 Your suggestion as to how to shorten it would be most welcome.
\end_layout

\begin_layout Section
LNCS Online
\end_layout

\begin_layout Standard
The online version of the volume will be available in LNCS Online.
 Members of institutes subscribing to the Lecture Notes in Computer Science
 series have access to all the pdfs of all the online publications.
 Non-subscribers can only read as far as the abstracts.
 If they try to go beyond this point, they are automatically asked, whether
 they would like to order the pdf, and are given instructions as to how
 to do so.
\end_layout

\begin_layout Standard
Please note that, if your email address is given in your paper, it will
 also be included in the meta data of the online version.
\end_layout

\begin_layout Section
BibTeX Entries
\end_layout

\begin_layout Standard
The correct BibTeX entries for the Lecture Notes in Computer Science volumes
 can be found at the following Website shortly after the publication of
 the book: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.informatik.uni-trier.de/~ley/db/journals/lncs.html
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Acknowledgments.
\end_layout

\begin_layout Standard
The heading should be treated as a subsubsection heading and should not
 be assigned a number.
\end_layout

\begin_layout Section
The References Section
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "references"

\end_inset


\end_layout

\begin_layout Standard
In order to permit cross referencing within LNCS-Online, and eventually
 between different publishers and their online databases, LNCS will, from
 now on, be standardizing the format of the references.
 This new feature will increase the visibility of publications and facilitate
 academic research considerably.
 Please base your references on the examples below.
 References that don't adhere to this style will be reformatted by Springer.
 You should therefore check your references thoroughly when you receive
 the final pdf of your paper.
 The reference section must be complete.
 You may not omit references.
 Instructions as to where to find a fuller version of the references are
 not permissible.
\end_layout

\begin_layout Standard
We only accept references written using the latin alphabet.
 If the title of the book you are referring to is in Russian or Chinese,
 then please write (in Russian) or (in Chinese) at the end of the transcript
 or translation of the title.
\end_layout

\begin_layout Standard
The following section shows a sample reference list with entries for journal
 articles 
\begin_inset CommandInset citation
LatexCommand cite
key "jour"
literal "false"

\end_inset

, an LNCS chapter 
\begin_inset CommandInset citation
LatexCommand cite
key "lncschap"
literal "false"

\end_inset

, a book 
\begin_inset CommandInset citation
LatexCommand cite
key "book"
literal "false"

\end_inset

, proceedings without editors 
\begin_inset CommandInset citation
LatexCommand cite
key "proceeding1"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "proceeding2"
literal "false"

\end_inset

, as well as a URL 
\begin_inset CommandInset citation
LatexCommand cite
key "url"
literal "false"

\end_inset

.
 Please note that proceedings published in LNCS are not cited with their
 full titles, but with their acronyms!
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "jour"
literal "false"

\end_inset

 Smith, T.F., Waterman, M.S.: Identification of Common Molecular Subsequences.
 J.
 Mol.
 Biol.
 147, 195–197 (1981)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "lncschap"
literal "false"

\end_inset

 May, P., Ehrlich, H.C., Steinke, T.: ZIB Structure Prediction Pipeline: Composing
 a Complex Biological Workflow through Web Services.
 In: Nagel, W.E., Walter, W.V., Lehner, W.
 (eds.) Euro-Par 2006.
 LNCS, vol.
 4128, pp.
 1148–1158.
 Springer, Heidelberg (2006)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "book"
literal "false"

\end_inset

 Foster, I., Kesselman, C.: The Grid: Blueprint for a New Computing Infrastructure.
 Morgan Kaufmann, San Francisco (1999)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "proceeding1"
literal "false"

\end_inset

 Czajkowski, K., Fitzgerald, S., Foster, I., Kesselman, C.: Grid Information
 Services for Distributed Resource Sharing.
 In: 10th IEEE International Symposium on High Performance Distributed Computing
, pp.
 181–184.
 IEEE Press, New York (2001)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "proceeding2"
literal "false"

\end_inset

 Foster, I., Kesselman, C., Nick, J., Tuecke, S.: The Physiology of the Grid:
 an Open Grid Services Architecture for Distributed Systems Integration.
 Technical report, Global Grid Forum (2002)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "url"
literal "false"

\end_inset

 National Center for Biotechnology Information, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.ncbi.nlm.nih.gov
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Appendix: Springer-Author Discount
\end_layout

\begin_layout Standard
LNCS authors are entitled to a 33.3% discount off all Springer publications.
 Before placing an order, the author should send an email, giving full details
 of his or her Springer publication, to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

orders-HD-individuals@springer.com
\end_layout

\end_inset

 to obtain a so-called token.
 This token is a number, which must be entered when placing an order via
 the Internet, in order to obtain the discount.
\end_layout

\begin_layout Section
Checklist of Items to be Sent to Volume Editors
\end_layout

\begin_layout Standard
Here is a checklist of everything the volume editor requires from you:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
settowidth{
\backslash
leftmargin}{{
\backslash
Large$
\backslash
square$}}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
advance
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmargin
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
labelsep
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
itemsep
\end_layout

\end_inset

8pt
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
relax
\end_layout

\end_inset

 
\begin_inset FormulaMacro
\newcommand{\labelitemi}{{\lower1.5pt\hbox{\Large$\square$}}}
\end_inset


\end_layout

\begin_layout Itemize
The final \SpecialChar LaTeX
 source files 
\end_layout

\begin_layout Itemize
A final PDF file 
\end_layout

\begin_layout Itemize
A copyright form, signed by one author on behalf of all of the authors of
 the paper.
 
\end_layout

\begin_layout Itemize
A readme giving the name and email address of the corresponding author.
 
\end_layout

\end_body
\end_document
